今天的内容：
     为什么要有协程？
        因为想在单进程中实现并发，于是创建了线程，一个进程中开多个线程实现并发；
        因为想在单线程内实现并发，于是创建了协程，一个线程中开多个协程实现并发。

        因为CPthon有GIL锁，限制了在同一个时间点，只能执行一个线程,所以想要在执行一个线程的期间，充分的利用CPU的性能，所以才有了想在单线程内实现并发的想法。
        并发：切换+保存状态
        cpu为什么要切换？
           1 因为某个程序阻塞了
           2 因为某个程序用完了时间片
           很明显，解决1这个问题才能提高效率
        所以想要实现单线程中的并发，就要解决在单线程内，多个任务函数中，某个任务函数遇见IO操作，马上自动切换到其他任务函数去执行。

     协程： 是一个比线程更加轻量级的单位，是组成线程的各个函数
            协程本身没有实体

         实现协程的模块：
         greenlet模块：能简单的实现函数与函数之间的切换，但是遇到IO操作，不能自动切换到其他函数中
            （1） 注册一下函数func，将函数注册成一个对象f1
                  f1 = greenlet(func)
            （2） 调用func，使    用f1.switch()，如果func需要传参，就在switch这里传即可

         gevent模块：可以实现在某函数内部遇到IO操作，就自动的切换到其他函数内部去执行,推荐使用。
             g = gevent.spawn(func，参数) 注册一下函数func，返回一个对象g
             gevent.join(g) #等待g指向的函数func执行完毕，如果在执行过程中，遇到IO，就切换
             gevent.joinall([g1,g2,g3])#等待g1 g2 g3指向的函数func执行完毕

   大的总结：协程是由用户自己去调度的，
       面试题：
       已经学习过了进程，线程，协程
            计算密集用多进程，可以充分利用多核cpu的性能，
            IO密集用多线程或者协程都行，转换效率更高。（注意，协程是在单线程中由程序员自己调用的，一般都比不上计算机自身的调度效率，所以一般优先选择多线程）
       多线程和协程的区别是：
            线程是由操作系统调度，控制
            协程是由程序员自己调度，控制


     IO多路复用
        阻塞IO
        非阻塞IO
        多路复用IO
        异步IO python实现不了，但是有tornado框架，天生自带异步

     面试题：
       select和poll和epoll的区别
          select和poll有一个共同的机制，都是采用轮训的方式去询问内核，有没有数据准备好了
          select有一个最大监听事件的限制，32位机限制1024，,6位机限制2048
          poll没有，理论上poll可以开启无限大，1G内存大概够你开10W个事件去监听

          epoll是最好的，采用的是回调机制，解决了select和poll共同存在的问题
          而且epoll理论上也可以开启无限多个监听事件

并发的本质：切换 + 保存状态







